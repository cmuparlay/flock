#define HASH 1
#define INIT_HANDLE 1

#include <atomic>
#include <random>
#include <thread>

#include "allocator/alignedallocator.hpp"
#include "data-structures/hash_table_mods.hpp"
#include "utils/hash/murmur2_hash.hpp"

using hasher_type    = utils_tm::hash_tm::murmur2_hash;
using allocator_type = growt::AlignedAllocator<>;
#include "data-structures/table_config.hpp"

using KV_Type = unsigned long;
using table_type =
  typename growt::table_config<KV_Type, KV_Type, hasher_type, allocator_type,
			       hmod::growable, hmod::deletion>::table_type;

using handle_type = typename table_type::handle_type;
thread_local handle_type *my_handle;

template <typename K,
	  typename V,
	  class Hash = std::hash<K>,
	  class KeyEqual = std::equal_to<K>>
struct unordered_map {

  table_type table;

  void set_handle() {
    my_handle = new handle_type(table.get_handle());
  }

  std::optional<V> find(const K& k) {
    auto r = my_handle->find(k);
    if (r == my_handle->end()) return std::optional<V>();
    else return (*r).second;
  }

  std::optional<V> find_(const K& k) {
    return find(k);
  }

  bool insert(const K& k, const V& v) {
    auto x = my_handle->insert(k, v);
    return x.second;
  }

  bool remove(const K& k) {
    return my_handle->erase(k);
  }

  unordered_map(size_t n) : table(table_type(n)) {
  }

  void print() {}
  long check() {
    long count;
    for (auto it = my_handle->begin(); it != my_handle->end(); it++) count++;
    return count;}
  static void clear() {}
  static void stats() {}
  static void reserve(size_t n) {}
  static void shuffle(size_t n) {}
};
